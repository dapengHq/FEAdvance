# 第4章 变量、作用域与内存 #

**本章内容**
- 通过变量使用原始值和引用值
- 理解执行上下文
- 理解垃圾回收
## 4.1 原始值和引用值
ECMAScript中的变量可以包含两种类型的数据：原始值和引用值。**原始值**（primitive value）就是最简单的数据。**引用值**（reference value）则是由多个值构成的对象。  

在把一个值赋给变量时，JavaScript引擎必须确定这个值是原始值还是引用值。  

保存原始值的变量是**按值访问**（by value）的，因为我们操作的就是存储在变量中的**实际值**。  

引用值是**保存在内存**中的**对象**。与其他语言不同，JavaScript不允许我们**直接访问内存位置**，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际操作的是对该对象的**引用（reference）**而非实际的对象本身。为此，保存引用值的变量是**按引用（by reference）访问**的。

### 4.1.1 动态属性
原始值和引用值的**定义方式**类似，都是创建一个变量，然后给其赋值。但是在变量保存了这个值之后，可以**对值做什么**，则大有不同。对于引用值而言，可以随时**添加、删除、修改**其属性和方法。如下例：
``` js
const obj = new Object();
obj.name = 'ls';
console.log(obj.name); // ls
// 我们可以访问这个新属性，直到对象被销毁或者属性被显式的删除。
```
因此，只有引用值可以**动态的添加**后面可以访问的属性。

原始值**不能**有属性（虽然给原始值添加属性不会报错）：
``` js
const person = 'ls';
person.age = 22;
console.log(person.age); // undefined
```

原始值的初始化只能使用**原始字面量**形式。如果使用`new`关键字，则JavaScript会创建一个`Object`类型的实例：
``` js
const person = new String('ls');
person.age = 22;
console.log(typeof person, person.age); // object  22
```
### 4.1.2 复制值
除了存储方式不同，原始值和引用至在通过**变量复制**时也不同。如下：
#### 1. 原始值复制
``` js
const num1 = 1;
const num2 = num1;
```
这里，num1包含数值5，当把num2初始化为num1时，num2也会得到数值5。但是这个值是存储在num1中值的**副本**，它们两个是完全独立的，所以这两个变量是可以**独立使用、互不干扰**的。如下图：
<img src='/images/copy_primitive.jpg' style='width:50%'>

#### 2. 引用值复制
在**通过变量**把引用值赋值给另一个变量时，复制的值实际上是一个**指针**，**指向存储在堆内存中的对象**。操作完成后，两个变量实际上**指向一个对象**，因此一个对象的变化会在另一个对象上体现出来。如下例：
``` js
const o1 = new Object();
const o2 = o1;
o1.name = 'reference';
console.log(o2.name); // reference
```
上例中，o1保存了一个新对象的实例。然后，这个值被赋值给o2，此时这两个变量都指向同一个对象，给o1创建name属性并赋值后，o2也可以访问。下图展示变量与堆内存的关系：

<img src='/images/copy_reference.png' style='width:50%'> 