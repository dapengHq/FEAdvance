# 第4章 变量、作用域与内存 #

**本章内容**
- 通过变量使用原始值和引用值
- 理解执行上下文
- 理解垃圾回收
## 4.1 原始值和引用值
ECMAScript中的变量可以包含两种类型的数据：原始值和引用值。**原始值**（primitive value）就是最简单的数据。**引用值**（reference value）则是由多个值构成的对象。  

在把一个值赋给变量时，JavaScript引擎必须确定这个值是原始值还是引用值。  

保存原始值的变量是**按值访问**（by value）的，因为我们操作的就是存储在变量中的**实际值**。  

引用值是**保存在内存**中的**对象**。与其他语言不同，JavaScript不允许我们**直接访问内存位置**，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际操作的是对该对象的**引用（reference）**而非实际的对象本身。为此，保存引用值的变量是**按引用（by reference）访问**的。

### 4.1.1 动态属性
原始值和引用值的**定义方式**类似，都是创建一个变量，然后给其赋值。但是在变量保存了这个值之后，可以**对值做什么**，则大有不同。对于引用值而言，可以随时**添加、删除、修改**其属性和方法。如下例：
``` js
const obj = new Object();
obj.name = 'ls';
console.log(obj.name); // ls
// 我们可以访问这个新属性，直到对象被销毁或者属性被显式的删除。
```
因此，只有引用值可以**动态的添加**后面可以访问的属性。

原始值**不能**有属性（虽然给原始值添加属性不会报错）：
``` js
const person = 'ls';
person.age = 22;
console.log(person.age); // undefined
```

原始值的初始化只能使用**原始字面量**形式。如果使用`new`关键字，则JavaScript会创建一个`Object`类型的实例：
``` js
const person = new String('ls');
person.age = 22;
console.log(typeof person, person.age); // object  22
```
### 4.1.2 复制值
除了存储方式不同，原始值和引用至在通过**变量复制**时也不同。如下：
#### 1. 原始值复制
``` js
const num1 = 1;
const num2 = num1;
```
这里，num1包含数值5，当把num2初始化为num1时，num2也会得到数值5。但是这个值是存储在num1中值的**副本**，它们两个是完全独立的，所以这两个变量是可以**独立使用、互不干扰**的。如下图：

<img src='/images/copy_primitive.jpg' style='width:50%'>

#### 2. 引用值复制
在**通过变量**把引用值赋值给另一个变量时，复制的值实际上是一个**指针**，**指向存储在堆内存中的对象**。操作完成后，两个变量实际上**指向一个对象**，因此一个对象的变化会在另一个对象上体现出来。如下例：
``` js
const o1 = new Object();
const o2 = o1;
o1.name = 'reference';
console.log(o2.name); // reference
```
上例中，o1保存了一个新对象的实例。然后，这个值被赋值给o2，此时这两个变量都指向同一个对象，给o1创建name属性并赋值后，o2也可以访问。下图展示变量与堆内存的关系：

<img src='/images/copy_reference.png' style='width:50%'> 

### 4.1.3 传递参数
ECMAScript中所有函数的参数都是**按值传递**的。这意味着**函数外的值**会被复制到函数**内部的参数**中，就像从一个变量复制到另一个变量一样。原始值，就跟原始值变量的复制一样；引用值，就跟引用值的复制一样。不过，虽然**变量有按值访问和按引用访问**，但是**传参只有按值传递**。

在按**值**传递参数时，**值**会被**复制**到一个**局部变量**（即一个**命名参数**，用ECMAscript的话说，就是arguments对象的一个**插槽**）。

在按**引用**传递参数时，值在**内存中的位置**（而不是“值”）会被保存到一个局部变量，这意味着**对本地变量（函数命名参数）的修改会反映到函数外部**（这在ECMAScript中是**不可能**的）。看下面这个例子：
``` js
function addTen(num){
    num+=10;
    return num;
}
let count = 20;
let result = addTen(count);
console.log(count); // 20  没有变化
console.log(result); // 30
```
在上例中，函数`addTen()`有一个参数`num`，它就是一个局部变量。在调用时，变量`count`被作为参数传入。`count`的**值**是20，这个**值**被复制到参数`num`以便在函数内部使用。在函数内部，参数`num`的值被加上了10，但是这**不会**影响外部的原始变量`count`。参数`num`和变量`count`的值互不影响，它们只是碰巧存储了一样的值而已。**如果**num是按引用传递的，那么count的值也会被修改为30。这个事实在原始值上体现的很明显，但是如果**变量中传递的是对象**，就没那么清楚了。比如下例：
``` js
function setName(obj){
    obj.name = 'bob';
}
const person = new Object();
setName(person);
console.log(person.name); // bob
```
这一次，我们创建了一个对象并保存在变量`person`中，然后这个对象被复制到参数`obj`中。在函数内部，`person`和`obj`都**指向同一个对象**。结果就是，**即使对象是按值传入函数的，`obj`也会通过引用访问对象**，由于`obj`指向的对象保存在全局作用域的**堆内存**中，所以在函数内部给`obj`添加`name`属性时，函数外部的对象也会反映这个变化。我们可能会**错误**的认为，当在局部作用域中修改对象而反映到全局时，就意味着参数是按引用传递的。为了**证明对象是按值传递的**，我们可以看下例：
``` js
function setName(obj){
    obj.name = 'AAA';
    obj = new Object();
    obj.name = 'BBB';
}
const person = new Object();
setName(person);
console.log(person.name); // AAA
```
如果`person`是按引用传递的，那么`person`应该自动将指针指向`name`为BBB的新对象，然而并没有，`person`的name还是AAA。这表明，函数中的参数的**值**改变后，**原始的引用**仍然没变。当obj在函数内部被**重写**时，它变成了一个**指向本地对象的指针**，这个本地对象在函数执行结束后被销毁。
::: tip 注意
ECMAScript中函数的**参数**就是**局部变量**。
:::

### 4.1.4 确定类型
`typeof`操作符在判断一个变量是否是字符串、数值、布尔值、符号、`undefined`时，是**最佳实践**。如果值是`null`或对象，`typeof`返回`object`。所以`typeof`对于引用值的用处不大，我们不关系一个值是不是对象，而是想知道它是什么类型的对象。

为此，ECMAScript提供了`instanceof`操作符，语法如下：
``` js
variable instanceof constructor;
```
如果变量是给定引用类型（由其原型链决定，将在第8章详解）的实例，则返回`true`：
``` js
console.log(person instanceof Object); // 变量person是Object吗？
console.log(test instanceof Function); // 变量test是Function吗？
console.log(reg instanceof RegExp); // 变量reg是RegExp吗？
```
按照定义，所有引用值都是`Object`的实例，因此通过`isntanceof`操作符检测任何引用值和`Object`构造函数都会返回`true`。类似的，如果用`isntanceof`操作符检查原始值，则始终返回`false`，因为原始值不是对象。

## 4.2 执行上下文和作用域
**上下文有与之关联的变量对象，嵌套的变量对象构成了作用域链。**(目前可以把变量对象理解为作用域这个抽象概念的实体，以后有更准确的理解再更新)

- **上下文**：变量或函数的**上下文**决定了它们可以**访问**哪些数据，以及它们的**行为**。分为全局上下文、函数上下文和块级上下文。

- **全局上下文**：**全局上下文**是最外层的上下文。根据ECMAScript实现是宿主环境，表示全局上下文的对象可能不同。比如在浏览器中，全局上下文就是`window`对象（第12章详解）。使用`var`定义的全局变量和函数都会成为`window`对象的属性和方法。使用`let`和`const`的顶级声明不会在全局上下文中，但在**作用域链的解析**上效果相同。

- **变量对象**：每个上下文都有与之关联的**变量对象**（variable object），上下文中定义的所有函数和变量都存在于这个对象上。

- **销毁**：函数上下文在其所有代码执行完毕后被**销毁**，全局上下文在应用程序退出前被销毁（比如关闭网页或退出浏览器），包括定义在它上面的所有变量和函数。

- **上下文栈(执行栈/调用栈)**：每个**函数调用**都有自己的上下文，当**代码执行流**进入函数时，函数的上下文被推到一个**上下文栈**上。在函数执行完后，上下文栈会弹出该上下文，将控制权返还给之前的执行上下文。ECMAScript**程序的执行流就是通过这个上下文栈进行控制的**。

- **作用域链**：上下文中的代码在执行的时候，会创建变量对象的一个**作用域链**（scope chain）。作用域链决定了各级上下文中的代码在访问变量和函数时的**顺序**。代码正在执行的上下文的变量对象始终位于作用域链的**最前端**。作用域链中下一个变量对象来自于**包含上下文**，以此类推至全局上下文，全局上下文的变量对象始终位于作用域链的**末端**。

- **标识符解析**：代码执行时的标识符解析是通过沿着作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链最前端开始，逐级完后，直到找到标识符。
举例如下：
``` js
var color = 'bule';
function changeColor(){
    let anotherColor = 'red';
    function swapColor(){
        let tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
        // 这里可以访问 color，anotherColor，tempColor
    }
    // 这里可以访问 color，anotherColor，但是访问不到tempColor
}
// 这里只能访问到 color
```
下图展示了上例的作用域链：

<img src="/images/scopechain.jpeg" style="width:50%">

由图可知，内部上下文可以通过作用域链访问外部上下文中的一切，但是外部上下文无法访问内部上下文中的任何东西。上下文直接的连接是**线性的、有序的**。例如，`changeColor()`上下文的作用域链中只有两个变量对象：它自己的和全局变量对象，因此，它不能访问`swapColor()`的上下文。
::: tip 注意
**函数参数**被认为是**当前**上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则。
:::
::: tip 理解：执行上下文栈
执行上下文栈（又称调用栈/执行栈），用于存储代码执行期间创建的所有上下文。具有**LIFO**（last in first out后进先出）的特性。

js代码首次运行，会先创建一个**全局上下文**并压入执行栈中，之后每次函数调用，都会创建一个新的**函数上下文**并压入栈内；由于执行栈后进先出的特性，可以理解为，js代码执行完毕之前，在执行栈底部永远有一个全局执行上下文。
```js
function f1(){
    f2();
    console.log(1);
}
function f2(){
    f3();
    console.log(2);
}
function f3(){
    console.log(3);
}
f1(); //  3  2  1
```
我们可以通过执行栈与上下文的关系来解释上述代码，为了方便理解，可以假定执行栈是一个数组，大致过程如下：
```js
// 代码执行前先创建全局执行上下文
ECStack = [globalContext];
// f1调用
ECStack.push('f1 functionContext');
// f1又调用了f2，在f2执行完毕之前无法console 1
ECStack.push('f2 functionContext');
// f2又调用了f3，在f3执行完毕之前无法console 2
ECStack.push('f3 functionContext');
// f3 执行完毕，输出3并出栈
ECStack.pop();
// f2 执行完毕，输出2并出栈
ECStack.pop();
// f1 执行完毕，输出1并出栈
ECStack.pop();
// 此时执行栈中只剩下一个全局执行上下文
```
:::
::: tip 理解：执行上下文的创建
执行上下文分为**创建和执行**两个阶段。

**创建阶段**

创建阶段主要负责**三件事**：确定this --- 创建词法环境组件（LexicalEnvironment）--- 创建变量环境组件（VariableEnvironment），用伪代码来表示：
``` js
ExecutionContext = {  
    // 确定this的值
    ThisBinding = <this value>,
    // 创建词法环境组件
    LexicalEnvironment = {},
    // 创建变量环境组件
    VariableEnvironment = {},
};
```
1. 确定this

    官方称为This Binding。  
    在**全局**执行性上下文中，this总是指向全局对象，如浏览器环境下指向window。  
    而在**函数**执行上下文中，this的值取决于函数的调用方式。

2. 词法环境组件

    词法环境是一个包含标识符变量映射的结构，标识符代表函数/变量的名称，变量是对原始值或实际对象的引用。  
    词法环境由**环境记录**和**对外部环境引用记录**组成。  
    其中**环境记录**用于存储当前环境中的变量和函数声明的实际位置。**对外部环境引入记录**用于保存自身环境可以访问的其他外部环境，有点作用域链的意思~  
    上下文包含全局上下文、块级上下文和函数上下文三种，词法环境分为**全局词法环境**和**函数词法环境**两种。  
    - 全局词法环境组件

        对外部环境的引入记录为`null`，因为它本身就是最外层环境。此外，还记录了当前环境下的所有属性、方法位置。
    - 函数词法环境组件

        包含函数中定义的所有属性方法和`arguments`对象。函数词法环境的外部环境可以是全局环境，也可以是其他函数环境。
    
    环境记录在全局和函数中也不同，全局中的环境记录叫**对象环境记录**，函数中环境记录叫**声明性环境记录**，伪代码展示如下：
    ``` js
        // 全局环境
        GlobalExectionContext = {
            // 全局词法环境
            LexicalEnvironment: {
                // 环境记录
                EnvironmentRecord: {
                    Type: "Object", //类型为对象环境记录
                    // 标识符绑定在这里 
                },
                outer: < null >
            }
        };
        // 函数环境
        FunctionExectionContext = {
            // 函数词法环境
            LexicalEnvironment: {
                // 环境纪录
                EnvironmentRecord: {
                    Type: "Declarative", //类型为声明性环境记录
                    // 标识符绑定在这里 
                },
                outer: < Global or outerfunction environment reference >
            }
        };
    ```
3. 变量环境组件

    变量环境也可以说是词法环境，它具备词法环境所有属性，一样有环境记录和对外部环境引入记录。在ES6中唯一的区别的**词法环境用于存储函数声明和let、const声明的变量**，而**变量环境仅仅存储var声明的变量**。  
    示例如下：
    ``` js
        let a = 20;  
        const b = 30;  
        var c;

        function multiply(e, f) {  
        var g = 20;  
        return e * f * g;  
        }

        c = multiply(20, 30);
    ```
    可以用伪代码描述上述代码中执行上下文的创建过程：
    ``` js
        //全局执行上下文
        GlobalExectionContext = {
            // this绑定为全局对象
            ThisBinding: <Global Object>,
            // 词法环境
            LexicalEnvironment: {  
                //环境记录
            EnvironmentRecord: {  
                Type: "Object",  // 对象环境记录
                // 标识符绑定在这里 let const创建的变量a b在这
                a: < uninitialized >,  
                b: < uninitialized >,  
                multiply: < func >  
            }
            // 全局环境外部环境引入为null
            outer: <null>  
            },
        
            VariableEnvironment: {  
            EnvironmentRecord: {  
                Type: "Object",  // 对象环境记录
                // 标识符绑定在这里  var创建的c在这
                c: undefined,  
            }
            // 全局环境外部环境引入为null
            outer: <null>  
            }  
        }

        // 函数执行上下文
        FunctionExectionContext = {
            //由于函数是默认调用 this绑定同样是全局对象
            ThisBinding: <Global Object>,
            // 词法环境
            LexicalEnvironment: {  
            EnvironmentRecord: {  
                Type: "Declarative",  // 声明性环境记录
                // 标识符绑定在这里  arguments对象在这
                Arguments: {0: 20, 1: 30, length: 2},  
            },  
            // 外部环境引入记录为</Global>
            outer: <GlobalEnvironment>  
            },
        
            VariableEnvironment: {  
            EnvironmentRecord: {  
                Type: "Declarative",  // 声明性环境记录
                // 标识符绑定在这里  var创建的g在这
                g: undefined  
            },  
            // 外部环境引入记录为</Global>
            outer: <GlobalEnvironment>  
            }  
        }
    ```
    由此可见，在执行上下文的**创建阶段**，函数声明和`var`声明的变量在创建阶段已经被赋予了一个值，`var`声明的变量被设置为`undefined`，函数被设置为了自身函数。而`let`、`const`声明的变量被设置为未初始化。

    这也就解释了**变量提升和函数声明提升的原理**，以及`let`、`const`为什么有**暂时性死区**，这是因为**作用域创建阶段js引擎对双方的初始化赋值不同**。

**执行阶段**

代码执行时根据之前的环境记录对应赋值，比如早期`var`在创建阶段为`undefined`，如果有值就对应赋值。像`let`、`const`的值未被初始化，有值就赋值，无值就赋值为`undefined`。
:::

### 4.2.1 作用域链增强

虽然执行上下文有**全局**上下文和**函数**上下文两种，但有其他方式来**增强作用域链**，增强作用域链是指在作用域链**前端临时**添加一个上下文，这个上下文在代码执行完之后会被**删除**。通常有两种情况会出现这个现象：
- `try/catch`语句的`catch`块
- `with`语句

对`with`语句而言，会向作用域前端添加指定的对象；对`catch`语句而言，会创建一个新的变量对象，这个变量对象包含要抛出的错误对象的声明。
``` js
let qs = '?name=111';
with(location){
const url = href + qs;
}
```
在上例中，`with`语句将`location`作为上下文，所以`location`会被添加到作用域链的前端。

### 4.2.2 变量声明

#### 1. 使用var的函数作用域声明
- 使用`var`声明变量，变量会自动添加到**最近的上下文**。在函数中，最近的上下文就是函数的局部上下文。
- 如果变量**未经声明就被初始化**了，它就会被自动添加到全局上下文（严格模式会报错，开发时禁止这样做）。
- `var`声明会被拿到函数或全局**作用域的顶部**，位于作用域中所有代码之前，即“**提升**”。通过在声明之前打印变量，可以验证声明被提升，此时会输出`undefined`。

#### 2. 使用let的块级作用域声明
- `let`声明的变量作用域是**块级**的，块级作用域由最近的一堆包含花括号{}界定。
- `let`与`var`的另一点不同是`let`不能在同一作用域内**重复声明**，`let`重复声明会报`syntaxerror`，而`var`重复声明只保留最后一个。
- `let`适合声明**迭代变量**，而`var`声明的迭代变量会被泄露到循环外部。

#### 3. 使用const的常量声明
- 除了在声明时**必须初始化**、声明后**不能重新赋值**外，其余都与`let`声明一样。
- `const`声明只应用到顶级原语或对象。也就是赋值为对象的const变量不能再赋值为其它引用值，但对象的**键不受影响**。
- 如果想让整个对象都不能修改，可以使用`Object.freeze()`。这样给属性赋值时不会报错，但是会**静默失败**。
``` js
const obj = Object.freeze({});
obj.name = 'xxx';
console.log(obj.name); // undefined
```
::: tip 最佳实践
在开发中应该尽可能的多使用`const`声明，其次是let声明。

由于`const`声明暗示变量的值是**单一类型**且**不可修改**，JavaScript运行时编译器可以将其所有实例都替换成**实际的值**，而不会通过查询表进行变量查找。谷歌的V8引擎就执行这种**优化**。
:::

#### 4. 标识符查找
- 当在特定上下文中为了读取或写入而引用一个标识符时，需要通过搜索来确定这个标识符代表什么。
- 搜索**开始于**作用域链**前端**，如果在**局部作用域**中找到了该标识符，则搜索停止，变量确定。如果没找到，就继续沿**作用域链**搜索（作用域链中的对象也有一个原型对象，所以搜索可能涉及每个对象的**原型链**）。一直持续搜索至**全局上下文**的变量对象。如果仍没有，就说明其**未声明**。
- 访问局部变量比访问全局变量要**快**，因为不用切换作用域。不过js引擎一直在优化标识符查找，所以将来这个差异可能微不足道。

## 4.3 垃圾回收
JavaScript是使用垃圾回收的语言（C和C++等语言需要开发者自行跟踪内存），也就是说**执行环境**负责在代码执行时管理内存，以实现**内存分配和闲置资源回收**。垃圾回收的**基本思路**是确定哪个变量不再使用就释放它占用的内存，这个过程是**周期性**的。主要有两种标记未使用的变量的策略：**标记清理和引用计数**。

内存的生命周期基本是以下三个阶段：
- 分配所需的内存空间
- 使用分配到的内存（读、写）
- 不需要时将其释放

以全局变量和局部变量来说，函数中的局部变量在函数执行后会被回收。而对于全局变量，垃圾回收器很难判断什么时候不再需要它们，所以应该**少用全局变量**。

### 4.3.1 标记清理
标记清理（mark-and-sweep）是JavaScript最常用的回收策略。它的**基本思路**是：从根部出发，看能否到达某个对象，能就认为该对象还被需要（还被引用），无法到达就释放它。整个过程分为三步：

- 垃圾回收器创建`roots`列表，`roots`通常是代码中保留引用的全局变量，在`js`中，一般认定`window`作为`root`，也就是所谓的根部。
- 从根部出发检查所有的`roots`，所有的`children`也会被递归检查，能从`root`到达的，都标记为`active`。
- 未被标记为`active`的对象被认定为不被需要，则释放它们。
<img src="/images/markAndSweep.gif">

当一个对象零引用时，我们从根部一定无法到达。反之则不然，也就是说从根部无法到达的对象，不一定是严格意义是零引用，比如循环引用，所以**标记清理优于引用计数**。
### 4.3.2 引用计数

引用计数的垃圾回收策略不太常用。其思路是**记录每个值被引用的次数**，垃圾回收机制运行时，**清除引用数为0的值的内存**。

声明变量并给它赋一个引用值时，这个值的引用数是1.如果同一个值又被赋值给另一个变量，引用数**加1**。如果保存对该值引用的变量被其他值覆盖了，那么引用数**减1**。

引用计数有一个严重的问题：**循环引用**。也就是对象A有一个指针指向对象B，对象B有一个指针指向对象A：
``` js
function problem(){
    let objA = new Object();
    let objB = new Object();
    objA.son = objB;
    objB.son = objA;
}
```
在上例中，`objA`和`objB`的引用数都是2。在标记清理策略下，函数结束后两个对象都不在作用域中，所以没问题。而在引用计数策略下`objA`和`objB`在函数结束后还会存在，因为引用数永远不会为0。如果函数多次调用还会导致大量内存不会被释放。

为了避免类似的循环引用问题，可以手动清除，如下：
```js
    objA.son = null;
    objB.son = null;
```
把变量设置为`null`会切断变量与其引用值之间的关系，就能解决循环引用，正确的进行垃圾回收。

### 4.3.3 性能

垃圾回收可能会**拖慢渲染的速度和帧速率**，尤其是在内存有限的移动设备上，所以垃圾回收的**时间调度**很重要。但是开发者不知道垃圾回收机制什么时候运行，所以**最佳实践**就是无论什么时候收集垃圾，都能让它尽快结束工作。

V8引擎的堆增长策略会根据活动对象的数量外加一些余量来确定何时再次进行垃圾回收。

### 4.3.4 内存管理

分配给浏览器的内存相较桌面软件**少**很多，这是为了避免运行大量的`JavaScript`的**网页耗尽系统内存导致操作系统崩溃**。这个**内存限制**不仅**影响变量分配**，也**影响调用栈以及能同时在一个线程中执行的语句数量**。

**将内存占用量保持在一个较小的值可以让页面性能更好**。**优化内存的最佳手段**就是保证在执行代码时只保存必要的数据。如果数据不再需要，就通过把它设置为`null`来进行**解除引用**。局部变量在超出作用域后会被**自动解除引用**，而全局变量和循环引用需要**手动解除引用**。解除引用的关键在于**确保相关的值已经不在上下文里**了。

#### 1. 通过const和let声明提升性能

在**块作用域比函数作用域更早终止**的情况下，使用这两个关键字会更早的让垃圾回收程序介入。

#### 2. 隐藏类

根据`JavaScript`所在的运行环境，，有时需要根据浏览器使用的`JavaScript`引擎来采取不同的性能优化策略。比如Chrome使用的V8 JavaScript引擎。V8 在将解释后的`JavaScript`代码编译成机器码时会利用”**隐藏类**“。在代码非常注重性能时，这很重要。

运行期间，V8 会将创建的对象和隐藏类关联起来，以跟踪它们的属性特性。能够**共享相同隐藏类的对象性能会更好**。请看如下代码：
``` js
    function Article() {
        this.title = "title";
        this.age = 22;
    }
    let a1 = new Article();
    let a2 = new Article();
```
V8 会在后台配置，让这两个类实例**共享相同的隐藏类**。因为它们共享**同一个构造函数和原型**。

但是**动态删除属性或动态添加属性，会使实例对象不再共享相同的隐藏类**。请看如下代码：
``` js
// 动态添加属性
a2.name = 'ls';
// 动态删除属性 delete
delete a2.age;
```

即便两个实例共享同一个构造函数，它们也不再共享同一个隐藏类。所以**最佳实践**是把不想要的属性设置为`null`，这样既能**保持隐藏类继续共享**，还能达到**解除引用，触发垃圾回收**的效果。请看如下代码：

```js
a1.title = null;
```

解决方案就是避免**先创建后赋值**(ready-fire-aim)式的动态属性操作，并**在构造函数中一次性声明所有属性**，如下所示：
``` js
function Article(arg) {
    this.name = arg;
    this.age = 22;
}

let a1 = new Article();
let a2 = new Article('ls');
```
#### 3. 内存泄露

根据前面垃圾回收机制的相关关系，我们知道没有被及时解除引用的变量或对象会引发内存泄露，那怎么解决这么问题呢？

- **全局变量**

在`window`对象上创建的属性，只要`window`本身不被清理就不会消失。
在开发过程中，我们应该尽量少使用全局变量。但是还有两种情况会使我们在不经意间创建全局变量：

a. 在函数中声明变量未使用`var`

b. 在函数体内通过`this`创建变量
``` js
function test() {
    a = 1;  // 未使用声明关键字
    this.b = 2;  // this指向window
}
window.a;  // 2
window.b;  // 2
```

- **定时器**

下面的代码中，定时器的回调通过闭包引用了外部变量：
``` js
let name = 'ls';
setInterval(()=>{
    console.log(name);
})
```
我们应该在不需要定时器时清除它。

- **事件监听**

应该在不需要时，移除事件监听：
``` js
let element = document.getElementById('btn');

function onclick(event) {
    element.innerHTML = 'text';
}
// 添加事件监听
element.addEventListener('click', onclick);

// 在不需要时及时移除事件监听
element.removeEventListener('click', onclick);
```

- **闭包**

对于闭包中的变量，在不需要时要解除引用。
``` js
let theThing = null;

let replaceThine = function () {
    let originalThing = theThing;
    let unused = function () {
        // unused虽然未执行，但是一直保持对theThing的引用
        console.log(originalThing);
    }
    theThing = {
        name : 111
    }
    originalThing = null; // 解除引用
}
replaceThine();
```
闭包`unused`始终保持着对`originalThing`的引用，因为赋值的缘故，也保持了对`theThing`的引用。正确做法是在`replaceThine`最后添加`originalThing = null`。

- **DOM的引用**

虽然操作DOM不好，但是一定要操作时，我们常用一个变量来把它存储取来，这样就能复用了。但是这也会导致dom被引用2次。
``` js
let element = document.getElementById('aa');

function doStuff(){
    element.innerHTML = 'text';
}

// 解除引用时要解除两次
element = null;
document.body.removeChile(document.getElementById('aa'));
```
在上述代码中，一次是基于dom树的引用，一次是变量`element`的引用，当我们不需要这个dom时，要做两次解除引用的操作。

#### 4. 静态分配与对象池

为了提升JavaScript性能，最后要考虑的就是压榨浏览器。如果能**合理使用分配的内存，避免对于的垃圾回收，就可以保住因释放内存而损失的性能**。

由于这种性能优化是一种极端形式，如果应用程序未被垃圾回收严重拖后腿，这种优化方式不需要考虑。所以在此不作过多记录，详见纸质书。